InnoDB Redo Logの解体新書：解析ツール構築のための物理・論理フォーマット完全ガイドI. InnoDB Redo Logの基礎原理InnoDB Redo Logの複雑なフォーマットを解析するツールを構築するには、まずその存在理由と、InnoDBアーキテクチャ全体における役割を深く理解することが不可欠です。Redo Logは単なるログファイルではなく、データベースのACID特性、特に永続性（Durability）と、高性能なトランザクション処理を実現するための根幹をなすメカニズムです。本章では、その基礎となる3つの重要概念、すなわち先行書き込みロギング（WAL）、バッファプールとの相互作用、そしてログシーケンス番号（LSN）について解説します。先行書き込みロギング（WAL）による永続性の保証リレーショナルデータベースにおける最も重要な要件の一つは、コミットされたトランザクションの変更が、システムクラッシュや電源断といった予期せぬ事態によって失われないこと、すなわち永続性です。InnoDBはこの永続性を保証するために、先行書き込みロギング（Write-Ahead Logging, WAL）と呼ばれる標準的な技術を採用しています 1。WALの原理は極めてシンプルです。データに対する変更を、実際のデータファイル（テーブルスペース）に書き込む前に、まずログファイル（Redo Log）に書き出すというものです。この一見単純な手順が、データベースのパフォーマンスと信頼性に劇的な影響を与えます。データファイルへの書き込みは、ディスク上の様々な場所に散らばったページを更新するため、本質的に低速なランダムI/Oとなります。もしトランザクションがコミットされるたびに、変更されたすべてのデータページをディスクに同期的に書き込んでいたのでは、書き込み性能は著しく低下し、現代的なOLTP（オンライントランザクション処理）ワークロードには到底耐えられません。WALは、この問題を解決します。Redo Logへの書き込みは、ファイルの末尾に追記していくだけの高速なシーケンシャルI/Oです。InnoDBは、トランザクションの変更内容をまずRedo Logに記録し、そのログレコードがディスクに永続化された時点でトランザクションのコミットを完了させます 3。これにより、たとえデータページ自体がまだディスクに書き込まれていない状態でサーバーがクラッシュしたとしても、ディスク上のRedo Logには変更の記録が残っているため、システムの再起動時にそのログを再生（リプレイ）することで、失われた変更を復元し、データベースをコミット直後の状態に戻すことができるのです 2。このアーキテクチャは、トランザクションのコミット処理と、低速なデータページのフラッシュ処理を非同期に分離することを可能にします。これにより、データベースは高い書き込みスループットを維持しながら、ACIDの「D」、すなわち永続性を厳密に保証することができるのです。したがって、Redo Logは単なる障害復旧のための安全策ではなく、InnoDBの高性能な書き込み処理を実現するための、極めて重要なパフォーマンス最適化機構でもあるのです。バッファプール、ダーティページ、クラッシュリカバリとの相互作用InnoDBのデータ操作は、すべてメモリ上のキャッシュ領域である「InnoDBバッファプール」を介して行われます。ディスクから読み込まれたデータページはバッファプールに配置され、UPDATEやINSERTといった変更処理も、まずこのメモリ上のページに対して実行されます。このようにメモリ上で変更されたものの、まだディスク上のデータファイルには書き込まれていないページを「ダーティページ（dirty page）」と呼びます 2。Redo Logに記録されるのは、まさにこのダーティページに対して行われた「変更内容の差分」です。システムが正常に稼働している間、InnoDBはバックグラウンドでダーティページを少しずつディスクに書き戻していきます。この処理は「ファジーチェックポイント（Fuzzy Checkpointing）」と呼ばれ、一度に大量のI/Oが発生してシステム全体の性能を低下させるのを防ぎます 5。ここでWALの役割が再び重要になります。もしサーバーがクラッシュすれば、メモリ上のバッファプール、つまりすべてのダーティページの内容は失われます。しかし、それらの変更内容はRedo Logとしてディスクに永続化されています 8。システムの再起動時に開始されるクラッシュリカバリ処理において、InnoDBは最後に成功したチェックポイント以降のRedo Logを読み込み、そこに記録されている変更をデータページに順次適用（リプレイ）していきます 2。このプロセスにより、クラッシュによって失われたメモリ上の変更が復元され、データベースは一貫性のある状態へと回復します。ログシーケンス番号（LSN）という中核座標系Redo Logとデータページの一貫性を管理し、クラッシュリカバリを正確に実行するために、InnoDBは「ログシーケンス番号（Log Sequence Number, LSN）」という極めて重要な概念を用いています。LSNは、単調に増加し続ける64ビットの整数値であり、Redo Logストリームに書き込まれた総バイト数を表します 9。これは、InnoDB内部におけるすべての変更操作の「時刻」や「座標」として機能する、普遍的な座標系と考えることができます。LSNは以下の2つの重要な場所に記録されます。Redo Logレコード: 生成されるすべてのRedo Logレコードには、そのレコードがログストリーム内のどの位置にあるかを示すLSNが付与されます。データページのヘッダ: 各データページのヘッダ領域には FIL_PAGE_LSN というフィールドがあり、そのページに対して最後に適用された変更のLSNが記録されています 2。この2つのLSNの存在が、クラッシュリカバリの冪等性（べきとうせい）、つまり処理を何度繰り返しても結果が同じになる性質を保証します。リカバリプロセス中、InnoDBはあるRedo Logレコードを適用しようとする際に、まず対象となるデータページの FIL_PAGE_LSN を確認します。そして、以下の比較を行います。page.LSN < record.LSNこの条件が真である場合、そのRedo Logレコードが記録した変更はまだページに適用されていないことを意味するため、変更が適用されます。逆に、page.LSN >= record.LSN であれば、その変更は既に（おそらくクラッシュ前に）ページに適用済みであることを意味するため、リプレイ処理はスキップされます 2。これにより、同じログを誤って二重に適用してしまうことを防ぎ、安全かつ正確なリカバリが可能になります。さらに、LSNは単なるリカバリのための仕組みに留まりません。現在書き込まれている最新のLSNと、最後に完了したチェックポイントのLSNとの差分（「チェックポイントエイジ」と呼ばれる）は、まだディスクに永続化されていない作業量を直接的に示す指標となります 5。InnoDBの「適応的フラッシュ（Adaptive Flushing）」アルゴリズムは、このチェックポイントエイジを監視し、その値に基づいてダーティページのフラッシュ量を動的に調整します 13。つまり、LSNは障害発生後のリカバリツールであると同時に、通常運転時のI/O負荷を管理し、システムスループットを最適化するための、ライブでクリティカルなメトリクスでもあるのです。II. 高レベルアーキテクチャ：二つのフォーマットの物語Redo Log解析ツールを開発する上で、開発者が直面する最も大きな分岐点が、MySQLのバージョンによるアーキテクチャの根本的な違いです。特に、MySQL 8.0.30で導入された変更は非常に大きく、ツールはこれら二つの異なるフォーマットを検知し、それぞれに対応できなければなりません。本章では、旧来の「循環バッファ」モデルと、最新の「動的Redo Logキャパシティ」モデルのアーキテクチャを比較・解説します。クラシックモデル（MySQL 8.0.30以前）：循環バッファMySQL 8.0.30より前のバージョンで長年採用されてきたのは、物理ファイルを循環的に利用するモデルです。物理的表現: このモデルは、データディレクトリ内に配置された、固定数の物理ファイルによって表現されます。デフォルトでは ib_logfile0 と ib_logfile1 という名前の2つのファイルが作成されます 3。設定: ファイルの数と各ファイルのサイズは、それぞれ innodb_log_files_in_group と innodb_log_file_size という設定パラメータによって決定されていました。これらの値を変更するには、MySQLサーバーの再起動が必須であり、運用上の大きな制約となっていました 3。動作原理: Redo Logの書き込みは、まず ib_logfile0 の先頭から始まり、ファイルの終端まで達すると、次に ib_logfile1 へと続きます。最後のログファイルの終端まで書き込みが進むと、再び ib_logfile0 の先頭へと「ラップアラウンド」します。このとき、ラップアラウンド先の領域に記録されていた古いログデータは、既にチェックポイント処理によってデータファイルへの反映が完了しているため、安全に上書きされます 9。この動作は、リングバッファや循環キューに例えることができます。図1: クラシックな循環バッファモデルの概念図。書き込み位置（write_pos LSN）が、チェックポイント位置（checkpoint LSN）を追いかける形で、物理ファイルを循環的に利用する。モダンモデル（MySQL 8.0.30以降）：動的Redo LogキャパシティMySQL 8.0.30では、運用上の柔軟性を大幅に向上させるため、Redo Logのアーキテクチャが刷新されました。導入背景: 最大の目的は、サーバーを再起動することなくRedo Logの総容量をオンラインで変更可能にすることでした。これは、クラウド環境や24時間365日のサービス継続が求められる現代の運用要件に応えるための重要な改善です 3。設定: 従来の innodb_log_files_in_group と innodb_log_file_size は非推奨となり、新たに動的変数である innodb_redo_log_capacity 一つで総容量を管理する方式に変更されました 3。物理的表現: ログファイルは、データディレクトリ内に新設された #innodb_redo という専用サブディレクトリに格納されるようになりました 3。ファイル管理: InnoDBは、総容量を約32個のファイルに分割して管理しようと試みます。これらのファイルは、その役割に応じて2種類に分類されます。アクティブファイル: #ib_redoNNNN という命名規則（NNNNはシーケンス番号）を持ち、現在有効なログデータを格納しています 3。スペアファイル: #ib_redoNNNN_tmp という _tmp サフィックス付きの命名規則を持ちます。これらは次に使用されるために事前に確保されたファイルであり、ファイル切り替え時の書き込み停止（ストール）を防ぐ役割を果たします 3。動作原理: この新しいモデルは、もはや循環バッファではなく、キュー（待ち行列）として機能します。書き込みが進み、チェックポイントLSNも前進すると、キューの先頭にある古い #ib_redoNNNN ファイルは不要になります。不要になったファイルは削除対象となり、代わりにキューの末尾に新しいスペアファイルが生成されます。この様子は、公式ブログで「蛇（有効なログデータの範囲）が、連続する檻（ログファイル）を次々と移動していく」と比喩的に説明されています 5。図2: モダンな動的キャパシティモデルの概念図。有効なログデータ（checkpoint_lsnからcurrent_lsnまでの「蛇」）がアクティブファイル群の一部を占有し、不要になったファイル（左側）が回収され、新しいスペアファイル（右側）が準備されるリニアなキュー構造。このアーキテクチャの変更は、単なる技術的な選択ではなく、運用上の要求から生まれた必然的な進化でした。旧来の巨大な2ファイル構成では、容量を解放するためにはファイル全体が不要になるまで待つ必要がありましたが、多数の小さなファイルに分割したことで、ファイル単位でのきめ細やかな領域管理が可能となり、オンラインでの容量変更という重要な運用機能が実現されたのです。解析ツールを開発する際には、このアーキテクチャの違いを最初に検知する必要があります。そのための最も確実で簡単な方法は、ファイルシステムの構造を確認することです。データディレクトリ直下に ib_logfile0 や ib_logfile1 が存在すればクラシックモデル、#innodb_redo サブディレクトリが存在すればモダンモデルであると判断できます 3。ツールはこの判定に基づき、内部のパーサーロジックを適切に切り替えるべきです。III. 物理ファイルフォーマット：深層へのダイブ高レベルなファイル配置を理解したところで、次はその内部、各ログファイルに記録されるバイナリデータの構造をバイトレベルで解き明かしていきます。これは、解析ツールが最初に行うべきバイナリパースの第一階層です。各Redo Logファイルは、ヘッダ領域と、それに続く多数のログブロックから構成されます。ログファイルヘッダの解剖（先頭2048バイト）全てのRedo Logファイルは、先頭の2048バイトがヘッダ領域として予約されています。この領域は、後続のログブロック群とは異なり、LSNシーケンスの一部としては扱われません 19。このヘッダ領域は、さらにいくつかのブロックに分かれています。初期ブロック（最初の512バイト）: ファイルの先頭から512バイトは、そのファイル全体に関するメタデータを含んでいます。ここには、Redo Logのフォーマットバージョン、作成したMySQLのバージョン情報、そして特に重要な2つのフィールドが含まれます 19。log_uuid: データベースインスタンスごとに一意に生成されるUUIDです。異なるインスタンスのログファイルが誤って混在するのを検出するために使用されます。start_lsn: このログファイルに記録されている最初のログブロックの開始LSNです。この値は、グローバルなLSN値を、このファイル内での相対的なオフセットに変換するための基準点となり、パーサーにとって不可欠な情報です。チェックポイントブロックの構造初期ブロックに続く領域（オフセット512から1535まで）には、2つの同一構造を持つチェックポイントブロックが配置されています。それぞれ LOG_CHECKPOINT_1（オフセット512）、LOG_CHECKPOINT_2（オフセット1024）と呼ばれます 19。アトミックな更新メカニズム: なぜ同じ情報が2つ存在するのでしょうか。これは、チェックポイント情報の更新をアトミック（不可分）に行うための仕組みです。InnoDBは、チェックポイントを書き込む際に、これら2つのブロックに交互に書き込みを行います。もし LOG_CHECKPOINT_1 への書き込み中にシステムがクラッシュした場合でも、もう一方の LOG_CHECKPOINT_2 には一つ前の有効なチェックポイント情報が破損なく残っています。これは、データページの破損を防ぐためのダブルライトバッファと同じ原理です 2。リカバリ時には、両方のブロックを読み込み、より新しい checkpoint_no を持つブロックを有効なものとして採用します。チェックポイントフィールドの詳細: 各チェックポイントブロックには、クラッシュリカバリの起点となる重要な情報が含まれています。フィールド名オフセット (ブロック内)サイズ (バイト)データ型説明checkpoint_no0x008uint64_tチェックポイントのシーケンス番号。この値が大きい方が新しいチェックポイントであることを示す。checkpoint_lsn0x088uint64_t最重要フィールド。このLSNより前のRedoレコードに対応するダーティページは、全てディスクにフラッシュ済みであることが保証される。クラッシュリカバリはこのLSNから開始される 5。offset0x108uint64_tcheckpoint_lsn がログファイル内のどのバイトオフセットに対応するかを示す。log_buf_size0x188uint64_tこのチェックポイントが書き込まれた時点での、メモリ上のログバッファのサイズ 19。checksum可変4uint32_tチェックポイントブロック自体の整合性を検証するためのチェックサム。表1: チェックポイントブロックの主要フィールド解析ツールが最初に行うべきタスクは、まさにこのチェックポイント情報を見つけ出すことです。ツールは、存在するすべてのRedo Logファイル（モダンフォーマットの場合は #innodb_redo ディレクトリ内の全ファイル）のヘッダをスキャンし、各ファイルから2つのチェックポイントブロックを読み込みます。そして、全ブロックの中から最も大きな checkpoint_no を持つものを探し出します。そのブロックに含まれる checkpoint_lsn こそが、データベース全体で有効な最後のチェックポイントであり、ログ解析を開始すべき「アンカー（錨）」となるのです。このアンカーを特定しない限り、どこからログを読み始めればよいか分からず、解析は正しく行えません。IV. ログブロック：I/Oの原子単位Redo Logファイルのヘッダ領域以降は、ログデータの本体が格納されています。このデータは連続したストリームではなく、「ログブロック」と呼ばれる固定長のブロックに分割されて記録されます。このログブロックは、ディスクI/Oの基本単位であり、その内部構造を理解することが、ログレコードを正しく読み解くための鍵となります。512バイトのログブロック構造Redo Logは、512バイトを1単位とするログブロックの連続として構成されています。このサイズは、古くからのハードディスクのセクタサイズに合わせて設計されており、ブロック単位の書き込みがアトミックに行われることを期待したものです 21。各ブロックは、厳密に以下の3つのパートから成ります。ヘッダ (LOG_BLOCK_HDR_SIZE): 先頭の12バイト。ブロックのメタ情報を含みます 2。データペイロード: ヘッダに続く最大496バイトの領域。実際のRedo Logレコードがここに格納されます。トレーラ (LOG_BLOCK_TRL_SIZE): 末尾の4バイト。ブロックの整合性を検証するためのチェックサムです 2。図3: 512バイトのログブロックの構造。12バイトのヘッダ、可変長のデータペイロード（未使用領域はゼロでパディングされる）、そして4バイトのトレーラで構成される。ログブロックヘッダ詳細各ブロックの先頭12バイトに格納されているヘッダは、ログストリームを航行するためのナビゲーション情報を提供します。フィールド名オフセット (ブロック内)サイズ (バイト)説明hdr_no0x004ブロックのシーケンス番号。基本的には LSN / 512 に相当し、ブロックの連続性を検証するために使用される。歴史的な理由で1Gでラップアラウンドする 19。data_len0x042このブロック内の有効なデータのバイト数（ヘッダの12バイトを含む）。512 の場合はブロックが完全に満たされていることを示す。12 から 508 の間の値は、このブロックが書き込みの最後のブロックであり、部分的にしか埋まっていないことを示す。0 は、有効なログデータがここで終了していることを示す 19。first_rec_group0x062重要フィールド。このブロック内で開始される**最初の新しいミニトランザクション（MTR）**へのオフセット（ブロック先頭から）。このブロックで新しいMTRが開始されない場合は 0 となる 19。epoch_no0x084ログのエポック番号。ログファイルが循環利用される際に、古いブロックと新しいブロックを区別するために使用される 19。表2: ログブロックヘッダのフィールドログブロックトレーラ：チェックサムによる整合性確保各ブロックの末尾4バイトには、そのブロックの内容（ヘッダとデータペイロード）から計算されたチェックサムが格納されています 2。書き込み中に電源断などが発生し、512バイトのブロックが部分的にしか書き込まれなかった場合（「Torn Page」問題）、再起動時にこのブロックを読み込むと、内容から計算したチェックサムとトレーラに記録されたチェックサムが一致しなくなります。リカバリプロセスや我々の解析ツールは、このチェックサムを検証することで、各ブロックが破損していないかを確認できます。チェックサムが不正なブロックを発見した場合、それは有効なログストリームの終端であると判断できます。この構造において、特に data_len フィールドは、解析ツールがログの終わりを検出するための主要なメカニズムとなります。ログファイルは事前に領域が確保されているため、ファイルの物理的な終端まで読み進めるのは間違いです。そこには古い、既に上書きされたデータが含まれている可能性があります。パーサーは、チェックポイントから始まり、ログブロックを一つずつ順に読み進め、各ブロックのチェックサムを検証し、data_len を確認しなければなりません。そして、data_len が 512 未満のブロックに到達したとき、それが有効なログストリームの最後のブロックであると判断します。これにより、クラッシュや正常シャットダウンの直前までに書き込まれた正確なログの範囲を特定することができるのです。V. 論理レイヤ：ミニトランザクション（MTR）の理解物理的なファイルやブロックの構造を理解しただけでは、Redo Logの内容を正しく解釈することはできません。その上には、個々のログレコードを意味のある単位にまとめるための「論理レイヤ」が存在します。その中核をなすのが「ミニトランザクション（Mini-Transaction, MTR）」という概念です。MTRを無視してログを解析すると、データの変更内容を誤って解釈する危険があります。MTR：アトミックな変更の単位ユーザーが発行する INSERT や UPDATE といった一つのSQL文は、InnoDBの内部ではさらに細かい複数の低レベルな操作に分解されます。例えば、B+Treeインデックスに新しいレコードを挿入する際、ページに空きがなければ「ページ分割」という操作が発生します。このページ分割では、新しいページを確保する元のページから一部のレコードを新しいページに移動する親ノードのポインタを更新して新しいページを指すようにするといった複数のページにまたがる、あるいは一つのページ内の複数箇所に対する変更が必要になります。これらの連続する変更は、全体として一つの不可分な（アトミックな）操作として実行されなければなりません。もし途中でクラッシュした場合、中途半端な状態でインデックスが残ると、構造が破壊され、データがアクセス不能になる恐れがあります 2。この「低レベル操作の原子性」を保証するのがMTRです。MTRは、このような一連の変更に必要な全てのRedo Logレコードをグループ化するための、メモリ上のオブジェクトです 23。重要なのは、MTRはユーザートランザクションとは異なり、ロールバックの概念を持たないことです 25。MTRの目的はあくまで、一連の物理的な変更をクラッシュセーフに、かつアトミックに適用するためのRedo Logを生成することにあります。MTRによるログレコードのバッファリングとグループ化内部的な処理の流れは以下のようになります。ページ分割のようなアトミックな操作が必要になると、まず mtr_start が呼び出され、MTRオブジェクトが生成されます 27。操作の過程で発生する個々の変更（例：バイト列の書き込み、レコードの挿入など）に対応するRedo Logレコードが生成され、それらはまずMTRオブジェクト内のプライベートなメモリバッファに書き込まれます 2。一連の操作がすべて完了すると、mtr_commit が呼び出されます。このタイミングで、MTRのプライベートバッファに溜め込まれていた全てのログレコードが、一つの連続した塊として、グローバルなログバッファにコピーされます 2。この仕組みにより、関連する一連のログレコードが、ログストリーム上で必ず隣接して配置されることが保証されます。ログストリームにおけるMTR境界の特定解析ツールは、このMTRの境界を正しく認識する必要があります。そのための手がかりは、ログブロックとログレコード自体に埋め込まれています。ログブロックヘッダの first_rec_group フィールドは、そのブロック内で最初に開始されるMTRの先頭レコードへのオフセットを示します 19。パーサーは、まずこのオフセットにジャンプすることで、MTRの開始位置を特定できます。MTRは、それが含むレコードの数によって、ログストリーム上での表現が異なります。単一レコードのMTR: MTRがただ一つのRedo Logレコードで構成される場合、そのレコードの先頭1バイト（タイプレコード）に特殊なフラグビットが立てられます。これにより、このレコードだけでMTRが完結していることが示されます 27。複数レコードのMTR: MTRが複数のレコードで構成される場合、最後のレコードの後に MLOG_MULTI_REC_END という特別な1バイトのレコードが追記されます。これがMTRの終端マーカーとなります 27。したがって、パーサーのロジックは次のようになります。first_rec_group から読み込みを開始し、最初のレコードのタイプをチェックします。単一レコードMTRのフラグが立っていれば、そのレコードを処理してMTRは終了です。そうでなければ、MLOG_MULTI_REC_END マーカーが出現するまで、後続のレコードを同じMTRの一部として読み込み続けます。個々の MLOG_* レコードがデータベースへの変更の「文字」だとすれば、MTRは意味のある「単語」に相当します。B+Treeの分割という操作は、複数の MLOG_* レコード（文字）から構成される一つのMTR（単語）として表現されます。クラッシュリカバリは、この「単語」単位で処理を行います。つまり、MTRの全てのレコードを適用するか、一つも適用しないかのどちらかであり、途中で中断することはありません 23。これにより、インデックスが破損した状態になることを防いでいます。したがって、高度な解析ツールは、単にログレコードを時系列でフラットに表示するだけでなく、MTR単位でグループ化して表示することで、InnoDBが内部でどのようなアトミックな操作を実行しているのか、よりリッチで正確な洞察を提供できるはずです。VI. ペイロードの解析：Redo Logレコードタイプこれまでの章で、Redo Logの物理的・論理的な構造、つまりログレコードがどのようにファイルに格納され、ブロックに分割され、MTRとしてグループ化されるかを解説しました。いよいよ最終階層である、個々のRedo Logレコード、すなわち「ペイロード」の解析に進みます。ここが、データベースに加えられた具体的な変更内容を解読する、最も詳細なレベルの作業となります。MLOG_* レコードタイプシステム全てのRedo Logレコードは、その種類を識別するための1バイトのタイプ情報から始まります。このタイプは、MySQLのソースコード内で MLOG_ というプレフィックスを持つ enum 定数として数十種類が定義されています（歴史的には storage/innobase/include/log0log.h などのヘッダファイルで定義されていました）2。これらのタイプは、それぞれが非常に具体的で低レベルな物理操作に対応しています。例えば、「ページ上の特定オフセットに1バイト書き込む (MLOG_1BYTE)」、「レコード全体を挿入する (MLOG_REC_INSERT)」、「ページを初期化する (MLOG_INIT_FILE_PAGE)」、「ファイルを作成する (MLOG_FILE_CREATE)」など、多岐にわたります 2。解析ツールの中核は、この1バイトのタイプ値を読み取り、それに応じて後続のペイロードの解析処理を振り分ける、巨大なswitch文のようなディスパッチャロジックになります。主要なレコードタイプのフォーマット詳細全てのレコードタイプを網羅することは現実的ではありませんが、ここでは特に重要ないくつかのレコードタイプのフォーマットを例として示し、解析の具体的なイメージを掴みます。例1: 物理的な書き込み (MLOG_WRITE_STRING)これは最も基本的なレコードタイプの一つで、ページ上の指定した場所に任意のバイト列を書き込む操作を記録します。そのペイロード構造は比較的単純です。[type:1][space_id:v][page_no:v][offset:2][len:2][data:len]type: レコードタイプ（例: MLOG_WRITE_STRING）。space_id: テーブルスペースID（可変長エンコーディング）。page_no: ページ番号（可変長エンコーディング）。offset: ページ内での書き込み開始オフセット（2バイト）。len: 書き込むデータの長さ（2バイト）。data: 実際に書き込むバイト列。例2: レコード挿入 (MLOG_REC_INSERT)これはより複雑で、InnoDBのログが「フィジオロジカル（Physiological）」と呼ばれる所以を示す典型的なレコードです。単なるバイト列ではなく、挿入されるレコードの論理的な構造情報を含んでいます 29。[type:1][space_id:v][page_no:v][offset:2][record_data...]record_data: 挿入されるレコード本体。これには、レコードヘッダ（フィールド数、NULLビットマップ、可変長フィールドのオフセット配列など）と、実際のカラムデータが含まれます。このレコードフォーマット自体も非常に複雑です 32。最適化: MLOG_REC_INSERT レコードは、ログサイズを削減するために様々な最適化が施されています。例えば、MySQL 9.2以降では、共通プレフィックス圧縮が導入され、隣接するレコード間で共通するキープレフィックス部分の記録を省略できるようになっています 30。例3: ページレベル操作 (MLOG_PAGE_CREATE)ファイルやページの作成・削除といった操作を記録するレコードは、ペイロードが非常に小さいか、あるいは全くない場合があります。[type:1][space_id:v][page_no:v]この場合、レコードタイプ自体が「space_id の page_no を作成した」という操作内容を示しており、パーサーはペイロードからデータを読み取るのではなく、レコードタイプに基づいて操作を解釈します 2。ソースコードからの完全なパーサー導出ガイドRedo LogのフォーマットはMySQLのバージョンアップに伴い変更される可能性があるため、堅牢な解析ツールを構築するためには、MySQLの公式ソースコードを直接参照することが不可欠です 15。特定のバージョンに対応した正確なパーサーを実装するには、以下の手順を踏むことが推奨されます。レコードタイプの定義を確認する: storage/innobase/include/log0log.h や関連するヘッダファイルを調べ、対象バージョンで定義されている MLOG_* の enum 定数の一覧と、それぞれの数値IDを把握します。解析ロジックを参照する: ソースコード内で log_parse_ というプレフィックスを持つ関数群（例: log_parse_redo_rec）を探します。これらの関数は、クラッシュリカバリ時にRedo Logを解析するためのロジックそのものであり、各レコードタイプのペイロードがどのように読み取られ、解釈されるかを示す最も信頼性の高いドキュメントです。このアプローチにより、ドキュメント化されていないフォーマットの変更にも追随し、特定のMySQLバージョンに対して完全に正確な解析ツールを開発することが可能になります。MLOG_* 定数名数値 (16進)概要代表的なペイロード構造MLOG_1BYTE0x01ページに1バイト書き込む[space_id][page_no][offset][value]MLOG_2BYTES0x02ページに2バイト書き込む[space_id][page_no][offset][value]MLOG_WRITE_STRING0x0Fページに任意の長さの文字列を書き込む[space_id][page_no][offset][len][data]MLOG_REC_INSERT0x09新しいレコードを挿入する[space_id][page_no][offset][record_data]MLOG_REC_DELETE0x0Cレコードを削除マークする[space_id][page_no][offset][len]MLOG_MULTI_REC_END0x1F複数レコードMTRの終端を示すなし (1バイトのみ)MLOG_PAGE_CREATE0x20新しいページを作成する[space_id][page_no]MLOG_CHECKPOINT0x24チェックポイント情報を記録する[checkpoint_lsn][offset]MLOG_FILE_CREATE0x2A新しいファイルを作成する[space_name][space_id]MLOG_FILE_DELETE0x2Cファイルを削除する[space_id]表3: 主要なMLOGレコードタイプとペイロードの概要Redo Logレコードの「フィジオロジカル」な性質は、データベース設計における重要なトレードオフを反映しています。ログは純粋な物理ログ（例：ディスクブロックの差分）ではありません。なぜなら、それではログが肥大化し、異なるハードウェア構成での再現性が失われるからです。一方で、純粋な論理ログ（例：SQL文）でもありません。なぜなら、リカバリ時にSQLを再実行するのは非常に低速だからです。フィジオロジカルログは、物理的なページアドレス（space_id, page_no）を指定しつつ 29、そのページ内での操作は論理的に（例：レコード挿入）記述するというハイブリッドなアプローチです 2。これにより、ログのコンパクトさと、高速なリカバリ性能を両立させているのです。解析ツール開発者はこの設計思想を理解することで、一見複雑に見えるレコードペイロードの構造を正しく解釈できるでしょう。VII. Redo Logアナライザ構築へのロードマップこれまでの章で詳述してきたRedo Logの階層構造とフォーマット情報を基に、本章では実際に解析ツールを構築するための具体的なステップバイステップの戦略を提示します。また、ゼロから実装する際の困難を軽減するため、既存のオープンソース実装をどのように活用できるかについても言及します。ステップ・バイ・ステップの解析戦略堅牢なRedo Log解析ツールは、以下の手順に従って実装することができます。このプロセスは、Redo Logの階層構造（ファイル -> ブロック -> MTR -> レコード）を忠実に反映しています。ログファイルの特定とバージョン検知:まず、解析対象のMySQLデータディレクトリを特定します。#innodb_redo サブディレクトリの存在を確認します。存在すればモダンフォーマット（MySQL 8.0.30+）、存在せず、代わりにデータディレクトリ直下に ib_logfile* ファイルがあればクラシックフォーマットと判断し、後続のファイル読み込みロジックを切り替えます。アンカーの発見（最新チェックポイントの特定）:特定した全てのRedo Logファイル（クラシックなら ib_logfile*、モダンなら #ib_redo*）のヘッダ領域（先頭2048バイト）を読み込みます。各ファイルから2つのチェックポイントブロック（LOG_CHECKPOINT_1, LOG_CHECKPOINT_2）をパースします。全てのチェックポイントブロックの中から、checkpoint_no フィールドの値が最も大きいものを探し出します。これがシステム全体で有効な最新のチェックポイントです。この最新チェックポイントブロックから checkpoint_lsn と、それが指すログファイル内のバイトオフセットを取得します。これが解析を開始すべき「アンカー」となります。シーケンシャルなブロック読み込みの開始:ステップ2で特定したアンカーのファイルオフセットから、512バイト単位でログブロックの読み込みを開始します。ブロックの検証:読み込んだ各512バイトブロックについて、まずトレーラに記録されているチェックサムを検証し、ブロックが破損していないことを確認します。チェックサムが不正な場合は、そこが有効なログストリームの終端である可能性が高いです。次に、ブロックヘッダの data_len フィールドを確認します。この値が 512 未満の場合、このブロックが部分的にしか埋まっていない最後のブロックであることを意味します。data_len を超える部分は無視します。data_len が 0 のブロックに遭遇した場合も、ログの終端と判断します。MTRのパース:検証済みのブロックの有効なデータペイロード内（ヘッダの12バイト後から data_len まで）で、MTRの境界を特定します。ブロックヘッダの first_rec_group フィールドが 0 でなければ、そのオフセットがブロック内で開始される最初のMTRの開始点です。各MTRの先頭レコードのタイプバイトを調べ、単一レコードMTRか複数レコードMTRかを判断します。複数レコードMTRの場合は、MLOG_MULTI_REC_END マーカーが出現するまでレコードを読み込み、一つのMTRとしてグループ化します。レコードパーサーのディスパッチ:MTR内に含まれる各ログレコードについて、先頭の1バイトを読み込み、MLOG_* タイプを特定します。特定したタイプに応じて、そのレコードタイプ専用の解析関数を呼び出します（ディスパッチ）。ペイロードのデコード:各レコードタイプ専用の解析関数は、ソースコードで定義されたフォーマットに従って、後続のペイロードをデコードします。これには、可変長エンコードされた数値の読み取りや、レコード構造の解析などが含まれます。出力と解析:デコードされた情報は、人間が読める形式（例：「MTR 123: テーブル 'db.users' のページ 5 にレコード 'xyz' を挿入」）で出力されるか、さらなる統計分析や可視化のために内部的なデータ構造に格納されます。次のブロックを読み込み、ステップ4から8をログの終端に達するまで繰り返します。既存実装の活用：innodb_ruby のケーススタディRedo Logのフォーマットは複雑であり、特にレコードペイロードの解析はバージョン間の差異もあって困難を伴います。このような複雑なバイナリフォーマットをリバースエンジニアリングする際には、既存のオープンソース実装を参考にすることが非常に有効です。その代表例が、Jeremy Cole氏によって開発された innodb_ruby です 35。これは、InnoDBの様々なファイルフォーマットをRubyで解析するためのライブラリであり、Redo Logのパーサーも含まれています。このプロジェクトは、以下のような点で解析ツール開発者にとって非常に価値のあるリソースです。実用的な実装例: innodb_ruby は、本レポートで解説した概念（ページ構造、ログブロック、ログレコードなど）の多くを実際にコードに落とし込んだ、動作する実装を提供します 35。学習ツールとして: そのソースコード、特に LogRecord や LogBlock に関連するファイルを研究することで、複雑な解析ロジックがどのように実装されるのかを具体的に学ぶことができます 35。これにより、多くの試行錯誤やリバースエンジニアリングの労力を削減できます。もちろん、innodb_ruby は特定のMySQLバージョンを対象としており、最新のフォーマット変更に完全に対応していない可能性もあります。しかし、基本的なアプローチやデータ構造の定義は、独自のツールを開発する上での優れた出発点となり、実装上の課題を解決するための貴重なヒントを提供してくれるでしょう。VIII. 結論と推奨事項本レポートでは、MySQL InnoDBのRedo Logについて、その基礎的な役割から、バージョン8.0.30におけるアーキテクチャの変遷、そしてファイル、ブロック、ミニトランザクション（MTR）、個々のレコードに至るまでの階層的なフォーマットを詳細に解説しました。この分析を通じて、Redo Log解析ツールの構築がいかに複雑で、しかし体系的なアプローチによって達成可能であるかが明らかになりました。主要な複雑性の要約Redo Logの解析における主な課題は、以下の3点に集約されます。アーキテクチャの分岐: MySQL 8.0.30を境とする、クラシックな循環バッファモデルとモダンな動的キャパシティモデルという根本的なアーキテクチャの違いが存在します。ツールは、ファイルシステムのレイアウトからこれを検知し、両方のモデルに対応できる必要があります。階層的な解析モデル: Redo Logは単純なバイトストリームではなく、ファイル -> ログブロック -> MTR -> ログレコードという厳密な階層構造を持っています。パーサーは、各階層の境界とメタデータを正しく解釈しながら、段階的に深層へと解析を進めなければなりません。特に、物理的なブロック構造と論理的なMTRの単位を区別して扱うことが重要です。ソースコードへの依存性: 個々のログレコード（MLOG_*）のペイロードフォーマットは非常に多様であり、バージョンアップによって変更される可能性があります。公式ドキュメントでは網羅されていない詳細な仕様も多く、信頼性の高いパーサーを実装するためには、最終的にMySQLのソースコードを参照することが不可欠となります。堅牢なツール構築のための推奨事項これらの複雑性を踏まえ、これからRedo Log解析ツールを開発するエンジニアに向けて、以下の点を推奨します。バージョン認識を前提とした設計: ツールの設計初期段階から、異なるMySQLバージョンに対応できることを念頭に置いてください。ファイルレイアウトに基づく自動的なバージョン検知と、それに応じたパーサーロジックの切り替え機構を組み込むことが、将来的なメンテナンス性を大きく向上させます。厳格な検証の実装: 各解析階層において、厳格なデータ検証を実装してください。ログブロックレベルでのチェックサム検証、ヘッダのマジックナンバー確認、LSNの連続性チェックなど、データの整合性を確認する仕組みを随所に設けることで、破損したログファイルを安全に処理し、ツールの安定性を高めることができます。論理構造を反映したコード設計: パーサーのコード構造を、Redo Logの論理的な階層（File, Block, MTR, Record）にマッピングすることで、可読性と保守性が向上します。各階層を表現するクラスやモジュールを定義し、責務を明確に分離することが望ましいです。オープンソースの活用: ゼロから全てを実装するのではなく、innodb_ruby のような既存のオープンソースプロジェクトを積極的に活用してください。これらのプロジェクトは、多くのリバースエンジニアリングの成果が凝縮された貴重な知識源です。コードを参考にしたり、あるいはこれらのツールを拡張・貢献したりすることで、開発労力を大幅に削減し、より高度な分析機能の実装に集中することができます。InnoDB Redo Logの解析は、データベースの内部動作を深く理解するための挑戦的かつ有益な取り組みです。本レポートが、その挑戦に臨む開発者にとって、信頼できる詳細なガイドとなることを期待します。
